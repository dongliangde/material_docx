## Nginx负载均衡的五种策略

### 1、轮询（默认）

每个请求按时间逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。

### 2、weight

指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。

权重越高，在被访问的概率越大。

### 3、ip_hash

上述存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。

我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自定定位到该服务器。

每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session共享问题

### 4、fair（第三方）

按后端服务器的响应时间来分配请求，响应时间短的优先分配。

### 5、url_hash

按照访问的url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。

## 什么是双亲委派模型？

### JVM的类加载器

![](<.gitbook/assets/20220209095940.png>)

JVM自带的类加载器包括启动类加载器、扩展类加载器和应用程序类加载器，此外还可以自定义类加载器。每个类加载器的作用都不一样。

**启动类加载器（Bootstrap ClassLoader）**

负责加载 JAVA_HOME\lib 目录下的类库，也就是JDK核心类库。

**扩展类加载器（Extension ClassLoader）**

负责加载 JAVA_HOME\lib\ext 这个子目录下的类库。

**应用程序类加载器（Application ClassLoader）**

负责加载用户类路径 Classpath 上的类库。

**自定义类加载器**

通过继承 java.lang.ClassLoader，根据不同的需求来实现自定义的类加载器，可以用来加载用户指定目录下的Class。在实际开发中，通过继承JDK中的类或者实现JDK中的接口来实现自定义类加载器。

### 类加载器工作流程：双亲委派

这些类加载器在加载某一个类的时候，具体的工作流程是怎样的？这里就要开始介绍重点：**双亲委派模型（Parent Delegation Model)**。

双亲委派模型包括两个过程，向上委派和向下委派。

双亲委派模型

![](<.gitbook/assets/20220209100002.png>)

**向上委派**

一个类在收到类加载请求后，不会自己马上加载这个类，而是把这个类的加载请求委派给它的父类去完成。父类收到这个请求后又会继续向上委派给父类的父类。以此类推，直到所有的请求委派到**Bootstrap ClassLoader**。

**向下委派**

当**Bootstrap ClassLoader**在接收到类加载请求后，如果发现自己无法加载这个类，比如这个类的Class文件不在加载路径中，那么父类就会向下委派子类加载器来加载这个类，直到这个请求被成功加载。

如果一直到最底层的自定义加载器都没有找到这个类的Class文件，那么JVM就会抛出**ClassNotFound**异常。

### 为什么采用双亲委派模型？

双亲委派模型的主要作用是保证JVM加载类的一致性，尤其是一些JDK中最基础的类。

如果没有使用双亲委派模型，由各个类加载器自行加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的ClassPath中，那系统将会出现多个不同的 Object 类，这样会导致Java类型的混乱。

双亲委派模型可以保证对于 Java.lang.Object 类，无论哪个类加载器要加载它，最终都会委派给Bootstrap ClassLoader，一定会加载 JAVA_HOME/lib 中的 Object 类。

另外双亲委派模型也可避免同一个类被加载多次，防止内存中出现多份同样的字节码。

**面试中经常会问到的一个问题：可以不可以自己写个String类？**

如果我们定义的完全类名是 java.lang.String, 我们知道基于双亲委派模型，会通过父加载器加载，那么最终到 Bootstrap ClassLoader 加载的就是标准JDK中的 String 类。其他加载器看到 String 类已经被加载，也就不会再重新加载 String 类了。

但是如果我们自定义的 String 类，包名不同的话，是可以重写的，在JVM看来，这其实是两个不同的类。

## 为什么要打破双亲委派模型

### 双亲委派模型

 ![](<.gitbook/assets/20220209101130.png>)

双亲委派模型就是将类加载器进行分层。在触发类加载的时候，当前类加载器会从低层向上委托父类加载器去加载。每层类加载器在加载时会判断该类是否已经被加载过，如果已经加载过，就不再加载了。这种设计能够避免重复加载类、核心类被篡改等情况发生。

双亲委派模型很好地解决了各个类加载器的基础类的统一问题，越基础的类由越上层的加载器进行加载。Java基础类一般都是被用户代码所调用的，那么是否存在基础类需要调用用户代码的情况呢？

主要场景就是JDK自身只提供接口规范，然后让第三方厂商去提供接口的具体实现，这样就会出现基础类调用厂商代码的情况，比如JDBC驱动类的加载，这类接口统称为服务提供者接口（SPI）。

**服务提供者接口（SPI）**

我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、XML解析模块、JDBC模块等。为了实现模块实现的可插拔，在模块装配的时候就需要一种服务发现机制。Java SPI就是一种为某个接口寻找实现的机制。

Java 提供了很多**服务提供者接口（SPI：Service Provider Interface）**，允许第三方为这些接口提供实现。常见的 SPI 包括 JDBC、JCE、JNDI、JAXP 和 JBI 等。

SPI机制允许Java程序在运行时才来加载具体的接口实现类，使用者只需要按照SPI规范指定具体的接口实现即可。通过这种方式，就实现策略模式和热拔插效果。

这些 SPI 接口在Java 核心库中，而实现代码则是在类路径（ClassPath）下的Jar包中。核心库中涉及到SPI接口的代码需要加载接口实现类。

### 为何要破坏双亲委派模型？

以JDBC为例，它的代码在rt.jar中，由启动类加载器去加载，但它需要调用厂商实现的SPI代码，这些代码部署在ClassPath下面。

根据双亲委派模型，启动类加载器无法直接委派应用程序类加载器（Application ClassLoader）来加载SPI的实现代码。那么启动类加载器如何找到这些代码呢？

JDK引入了**线程上下文类加载器（TCCL：Thread Context ClassLoader）**，线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链，利用线程上下文类加载器去加载所需要的SPI代码。

TCCL是从JDK1.2开始引入的，可以通过 java.lang.Thread 类中的 getContextClassLoader()和 setContextClassLoader(ClassLoader cl) 方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的默认上下文类加载器是 Application ClassLoader。

 ![](<.gitbook/assets/20220209101258.png>)

连接Mysql数据库时需要加载Mysql的JDBC驱动 com.mysql.jdbc.Driver。

DriverManager调用 getConnection() 连接数据库时，会触发 ServiceLoader.load(Driver.class)。

load() 函数会通过 Thread.currentThread().getContextClassLoader(）获得当前线程的上下文类加载器，完成驱动类加载。

 ![](<.gitbook/assets/20220209101358.png>)

接下来在Classpath的jar包中查找，如存在
META-INF/services/java.sql.Driver 文件，则加载其实现类，比如
mysql-connector-java-5.1.44.jar。从上图的调用链中，可以知道此时使用的类加载器是线程上下文类加载器，这就是SPI机制的核心原理。

Spring框架也用到了**线程上下文类加载器（TCCL）**，来加载WEB-INF下的用户代码，同样也是打破了双亲委派模型的加载链。

## docker资源限制

## MySQL慢查询

## MySQL隔离级别

## 三次握手

## 四次挥手

