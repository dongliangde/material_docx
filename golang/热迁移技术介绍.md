## 1.CRIU介绍

​	CRIU（Checkpoint/Restore In Userspace）运行在linux操作系统上的一个软件工具，其功能是在用户空间实现Checkpoint/Restore功能。使用这个工具，你可以冻结一个正在运行的程序，并且checkpoint它到一系列的文件，然后你就可以使用这些文件在任何主机重新恢复这个程序到被冻结的那个点(白话就是实现对已运行程序的备份和恢复)。所以criu通常被用在程序或者容器的热迁移、快照、远程调试等。

## 2.CRIU工作原理

![1328430-20180905115628923-1702357844](C:\Users\cq\Desktop\1328430-20180905115628923-1702357844.png)

### 2.1 Dump（进程冻结）

​	通过进程号，实现暂停进程的执行，备份相关数据到imgdir目录后杀死进程，同时需要注意的是criu需要root权限才可以运行，执行操作完成后可以看到imgdir目录会生成很多*.img文件，这些文件保存了进程被criu杀死之前的所有信息，criu将使用这些文件在任何其他同体系架构的主机上对进程程序做恢复。

### 2.2 Restore（进程恢复）

​	通过img文件，恢复被加载的进程，恢复时需要考虑生产中的程序并非如此简单。很多程序都是功能复杂，比如程序中可能有多个进程、有多个线程、有共享内存的使用、有tty设备的使用、有网络的使用、有ipc的使用等等。通过restore命令参数的设置都可以成功的对相关状态进行备份和恢复。 

## 3、CRIU高级特性

###  3.1 热迁移（Live migration）

  criu的主要功能就是可以实现程序的热迁移，但是需要手动编写很多命令。P.Haul项目提供了一个Go语言版本的库，封装了criu命令的复杂性，可以让我们更轻松的完成程序的热迁移工作。其源码地址是 https://github.com/checkpoint-restore/go-criu

### 3.2 代码动态注入（Parasite code injection）

  为了获取已运行进程的当前状态，CRIU需要让此进程执行一些代码去捕获当前进程相关信息。为了在不杀死此进程的情况下而实现这个功能，CRIU实现了代码动态注入（parasite code injection）技术。

### 3.3 TCP sockets checkpoint-restore

  CRIU另一个特性之一就是有能力在不破坏一个TCP链接的情况下，备份和恢复它的状态。这个功能不仅对CRIU本身有用，同时还可以通过它封装的库libsoccr单独使用。

## 4、CRIU实现原理

  CRIU的功能的实现基本分为两个过程,checkpoint()和restore。在checkpoint过程，criu主要通过ptrace机制把一段特殊代码动态注入到dumpee进程（待备份的程序进程）并运行，这段特殊代码就实现了收集dumpee进程的所有上下文信息，然后criu把这些上下文信息按功能分类存储为一个个镜像文件。在restore过程。criu解析checkpoint过程产生的镜像文件，以此来恢复程序备份前的状态没，让程序从备份前的状态继续运行。
  下面详细介绍checkpoint和restore这两个过程。

### 4.1 Checkpoint

 checkpoint的过程基本依赖ptrace功能实现。程序严重依赖**/proc**文件系统，它从/proc收集的信息包括：

文件描述信息（通过/proc/pid/fd 和 /proc/pid/fd 和 /proc/pid/fd和/proc/pid/fdinfo）
管道参数信息
内存表（通过/proc/pid /maps 和 / pr c / pid/maps** 和 **/proc/pid/maps∗∗和∗∗/proc/pid/map_files/**）
  checkpoint过程中，criu做的工作由如下步骤组成：
说明：在描述checkpoint中，我们把criu进程称为dumper进程，简称dumper。把要备份的进程称为dumpee进程，简称dumpee。

#### 步骤1：收集并且冻结dumpee的进程树

  dumper通过dumpee的pid遍历/proc/pid/task/路径收集线程tid，并且递归遍历/proc/pid/task/ pid/task/pid/task/tid/children，然后通过ptrace函数的PTRACE_ATTACH和PTRACE_SEIZE命令冻结dumpee程序。

#### 步骤2：收集dumpee的资源并保存

  在这个阶段，dumper获取dumpee的所有可获取的资源信息并写到文件里。这些资源的获取通过如下步骤：

通过 /proc/p i d / s m a p s ∗ ∗ 解 析 所 有VMAs区 域 ， 并 且 通 过 ∗ ∗ / p r o c / pid/smaps** 解析所有VMAs区域，并且通过**/proc/pid/smaps∗∗解析所有VMAs区域，并且通过∗∗/proc/pid/map_files 连接读取所有maps文件。
通过 /proc/$pid/fd获取文件描述号。
通过ptrace接口和解析/proc/$pid/stat块完成一个进程的核心参数（寄存器和friends）的获取。
通过ptrace接口向dumpee注入parasite code。这个过程由两步完成：首先注入mmap系统调用到任务被冻结那一刻的CS:IP位置，然后ptrace允许我们运行这个被注入的系统调用，这样我们就在被监控进程里申请到了足够的内存用于parasite code块。接下来把parasite code拷贝到这个新申请到的内存地址，并把CS:IP指向到parasite code的位置。
从注入上下文，CRIU可以获取更多的信息，比如认证、内存容量等。

#### 步骤3：清理dumpee

  dumper获取到dumpee所有信息（比如内存页，它只能从被监控程序内部地址空间写出）后，我们使用ptrace的系列参数去掉步骤2中对dumpee进程的修改。主要是对被注入代码的清理并并恢复dumpee的地址空间。基本通过PTRACE_DETACH 和 PTACE_CONT。然后criu可以选择杀死dumpee或者让dumpee继续运行。上面的test实例中选择的就是在备份dumpee后杀死进程，实际工作中，如果要对程序做差分备份（或者叫增量备份）时可以选择继续运行dumpee。

### 4.2 Restore

  恢复程序的过程完全依赖checkpoint过程后产生的镜像文件，主要过程分如下4步：

#### 步骤1：处理共享资源

  在这个步骤里，criu读取*.img镜像文件并找出哪些（子）进程共享了哪些资源，比如共享内存。如果有共享资源存在，稍后共享资源由这个程序的某个（子）进程还原，其他进程要么在第2阶段继承一个（如会话），要么以其他方式获取。例如，后者是通过unix套接字与SCM-CREDS消息一起发送的共享文件，或者是通过memfd文件描述符还原的共享内存区域。

#### 步骤2：生成进程树

  在这一步，CRIU会调用fork()函数一次或多次来重新创建所需进程。

#### 步骤3：恢复基本的资源信息

  在此阶段CRIU打开文件、准备namespaces、重新映射所有私有内存区域、创建sockets、调用chdir() 和 chroot()等等。

#### 步骤4：切换到dumpee的上下文

  通过将restorer.built-in.bin的代码注入到dumpee进程，来完成余下的内存区域、timers、credentials、threads的恢复。

## 5、CRIU的使用和接口

CRIU不仅提供了命令行工具CLI供使用，还提供远程调用方式的RPC接口。同时还封装了一个本地接口库API供开发使用。 

 使用C/R功能的三种方式就是 CLI, RPC and C API。下面分别介绍。 

### 1、CLI

   CLI（Command Line Implementation）意思是CRIU的命令行工具，具体的工具名称是criu。比如我们可以执行最简单的命令” `criu check“来确认当前系统内核是否提供支持CRIU正常使用的最小要求，如果条件达到，终端会返回成功，如下所示：` 

```
[root@localhost criu]# ./criu check
Looks good.
```

其他命令选项还有如下两个：

```
 criu dump|pre-dump -t PID [<options>] 通过PID值来备份一个进程。
  criu restore [<options>]                           恢复一个进程。
```

### 2、RPC

  CRIU-RPC 是一个使用Google Protocol Buffers的远程调用协议，请求在”swrk“模式下或者通过”criu service“命令启动的服务下保存。 在单例服务下，通过监听/var/run/criu-service.socket来实现通信。

   RPC中，发送和请求使用结构体criu_req和criu_resp 。基本过程就是：客户端发送criu_req消息给服务端，服务端使用criu_resp回复客户端。这两个结构体的类型如下：

```
message criu_req {
	required criu_req_type type	= 1;
	optional criu_opts opts		= 2;
	optional notify_success         = 3; /* see Notifications below */
	optional keep_open              = 4; /* for multi-req, below */
}

message criu_resp {
	required criu_req_type		type		= 1;
	required bool			success		= 2;
    optional criu_dump_resp		dump		= 3;
    optional criu_restore_resp	restore		= 4;
    optional criu_notify		notify		= 5;
    optional criu_page_server_info	ps		= 6;
	optional int32			cr_errno	= 7;
}
```

比如我们可以使用如下CLI命令去备份一个进程：

```
# criu restore -D /path/to/imgs_dir -v4 -o restore.log
```

它就等价于：

```
request.type = RESTORE;
 
request.opts.imgs_dir_fd	= open("/path/to/imgs_dir")
request.opts.log_level		= 4
request.opts.log_file		= "restore.log"
```

### 3、C API

libcriu 是CRIU的 c语言 API ，实际上是对上面CRIU-RPC的一个简单封装，所以libcriu提供了比直接使用RPC方式更加容易使用的C语言接口。 libcriu 提供的函数接口定义在lib/criu.h。criu源码编译完成后，此库在./lib/c/libcriu.so。里面提供的接口有：

```
void criu_set_pid(int pid);
void criu_set_images_dir_fd(int fd); /* must be set for dump/restore */
void criu_set_leave_running(bool leave_running);
void criu_set_ext_unix_sk(bool ext_unix_sk);
void criu_set_tcp_established(bool tcp_established);
void criu_set_evasive_devices(bool evasive_devices);
void criu_set_shell_job(bool shell_job);
void criu_set_file_locks(bool file_locks);
void criu_set_log_level(int log_level);
void criu_set_log_file(char *log_file);

int criu_check(void);
int criu_dump(void);
int criu_restore(void);
```

​      比如我们通过CLI 命令行 实现一个进程的恢复过程，具体是：

```
# criu restore -D /path/to/imgs_dir -v4 -o restore.log
```

就等价于：

```
criu_init_opts();
criu_set_service_address("/path/to/criu/service/socket");
 
int fd = open("/path/to/imgs_dir", O_DIRECTORY);
criu_set_images_dir_fd(fd);
 
criu_set_log_file("restore.log");
criu_set_log_level(4);
 
criu_restore();
```